# GDT LDT IDT相关

## GDT 

在进入32位保护模式后，采用一个全局唯一的表存储各个段起始位置、长度、权限等，该表是GDT(Global Descriptor Table)，GDT表存储在内存中，表的每一项都是一个长度位64位的数据结构。当需要切换段时，保护模式下的段寄存器作为段选择子从GDT表中选择一个段作为逻辑地址的段地址。

#### GDTR

在CPU中有一个**GDTR寄存器**记录内存中GDT表的起始位置。GDTR是**48位寄存器，高32位是GDT表起始位置，低16位是GDT表的限制长度** 限制长度以字节位单位，初始值0xffff，*len=8\*GDT项数-1*，

#### 段选择子

实模式下的**16位段寄存器**用于从GDT中选择某一个项，高13位为GDT项号，2位是TI标志0-GDT，1-LDT，01位表示访问者权限，0-3权限依次降低。
注意：CPU中存在一个高速缓存存储某个段描述符，当段选择子内容更换后，会更新该段描述符的高速缓存。
```
-----------------------------
|       Index    | TI | RPL |
-----------------------------
```


#### GDT表项

GDT表项总长64位，其中包含了**32位段基地址**、**20位长度**、**8位Access**、**4位flag**。
各个部分结构如下，BAES和LIMIT分布在GDT项的各个位置。7-15位Access、20-23位flag。

```
31          24        19      16              7            0
------------------------------------------------------------
|             | |B| |A|       | |   | |0|E|W|A|            |
| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4
|             | |D| |L| 19:16 | |   | |1|C|R|A|            |
------------------------------------------------------------
|                             |                            |
|        BASE 15:0            |       LIMIT 15:0           | 0
|                             |                            |
------------------------------------------------------------
```
1、G位(bit 55)表示限制长度粒度。
- G=0表示1字节计算长度，段长度范围（1B～1MB）;
- G=1表示4K字节计算长度，段长度范围（4KB～4GB）

2、P标志(bit 47)。说明该内存段是否已经存在于内存中。如果P = 0，那么在访问这个内存段的时候将报错。
3、DPL权限（bit 45-46）。段访问权限0-3，依次降低
4、S标记（bit 44）段的类型，S = 0说明这个内存段是一个系统段；S = 1说明这个内存段是一个代码段或者是数据段（ 堆栈段是一种特殊类型的数据段，堆栈段必须是可以进行读写的段 ）。

当S=1时，TYPE如下。第43位是0的时候，这个段描述符对应的是一个数据段，如果该位是1，那么表示这个段描述符对应的是一个代码段，对于数据段，第42，41，40位表示的是(E扩展，W可写，A可访问）；对于代码段，第42，41，40位表示的是(C一致，R可读，A可访问）。
- 如果E = 0，数据段是向上扩展数据段，反之为向下扩展数据段。关于向上扩展和向下扩展数据段，可以参考下面的链接。在一般情况下，应该是不会使用向下扩展数据段的。
- 如果W = 1，说明这个数据段是可写的，否则不可写。所有数据段都是可读的。
- A位表示该内存段是否已经被CPU访问。
- 如果C = 1，说明这个代码段可以被低优先级的代码访问，比如可以被用户态代码访问。反之如果C = 0，说明只能同优先级的代码段可以访问。
- 如果R = 1，说明该代码段可读。代码段是永远没有写权限的。

```
|           Type Field        | Descriptor Type | Description
|-----------------------------|-----------------|------------------
| Decimal                     |                 |
|             0    E    W   A |                 |
| 0           0    0    0   0 | Data            | Read-Only
| 1           0    0    0   1 | Data            | Read-Only, accessed
| 2           0    0    1   0 | Data            | Read/Write
| 3           0    0    1   1 | Data            | Read/Write, accessed
| 4           0    1    0   0 | Data            | Read-Only, expand-down
| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed
| 6           0    1    1   0 | Data            | Read/Write, expand-down
| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed
|                  C    R   A |                 |
| 8           1    0    0   0 | Code            | Execute-Only
| 9           1    0    0   1 | Code            | Execute-Only, accessed
| 10          1    0    1   0 | Code            | Execute/Read
| 11          1    0    1   1 | Code            | Execute/Read, accessed
| 12          1    1    0   0 | Code            | Execute-Only, conforming
| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed
| 13          1    1    1   0 | Code            | Execute/Read, conforming
| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed
```

3、AVL标志(bit 52) - 这个位在Linux内核中没有被使用。
4、L 标志(bit 53) - 只对代码段有意义，如果L = 1，说明该代码段需要运行在64位模式下。

---

## LDT 

局部描述符表LDT（Local Descriptor Table）局部描述符表可以有若干张，每个任务可以有一张。我们可以这样理解GDT和LDT：GDT为一级描述符表，LDT为二级描述符表。LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中。LDTR记录局部描述符表的起始位置，与GDTR不同LDTR的内容是一个段选择子。由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个表述符也会有一个选择子，LDTR装载的就是这样一个选择子。

## IDT






