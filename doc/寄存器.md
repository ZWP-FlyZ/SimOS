# X86芯片所有寄存器资料

## 一、通用寄存器

通用寄存器在大多数时候是通用的。当每个寄存器都有隐含的用法，某些指令会对特定的寄存器发生作用。
通用寄存器包含以下几个，
**E*X**的是32位寄存器， ***X**寄存器表明上一级的后16位， ***H**高8位 ***L**低8位， 注意:同系的寄存器相互关联。
| 寄存器 | 说明 |
| --- | --- |
| EAX -> AX -> AH+AL | 累加器寄存器 |
| EBX -> BX -> BH+BL | 基址寄存器，常用于地址偏移量 |
| ECX -> CX -> CH+CL | 计数寄存器  |
| EDX -> DX -> DH+DL | 数据寄存器 |
| ESI -> SI          | 源索引寄存器 |
| EDI -> DI          | 目的索引寄存器 |
| ESP -> SP          | 栈指针寄存器，通常指向栈顶 |
| EBP -> BP          | 基指针寄存器，通常指向一个**栈帧**的底部 |

某些指令或者外界事件需要特定的寄存器用于传输信息，特定的寄存器用于接收结果。

---
## 二、标志寄存器

EFLAGS -> FLAGS 标志寄存器提供程序的状态以及相应的控制。32位的EFLAGS提供了一组状态信息、系统标志、一个控制标志。

### 1、状态标志位

EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)是指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：

- **CF(bit 0) [Carry flag]**   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。
- **PF(bit 2) [Parity flag]**   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。
- **AF(bit 4) [Adjust flag]**   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。
- **ZF(bit 6) [Zero flag]**   若结果为0则将其置1，反之清零。
- **SF(bit 7) [Sign flag]**   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)
- **OF(bit 11) [Overflow flag]**   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。

在这些状态标志中，只有CF标志能够通过使用STC, CLC以及CMC指令被直接修改，或者通过位指令(BT, BTS, BTR以及BTC)将指定的位拷贝至CF标志中。

### 2、控制标志位

- **DF(bit10)[Direction flag]** 控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。*STD*以及*CLD*指令分别用于设置以及清除DF标志。

### 3、系统标志位

EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们**不允许被应用程序所修改**。这些标志的作用如下：

- **TF(bit 8) [Trap flag]** 将该位设置为1以允许单步调试模式，清零则禁用该模式。

- **IF(bit 9)[Interrupt enable flag]** 该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。

- **IOPL(bits 12 and 13) [I/O privilege level field]** 指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。

- **NT(bit 14) [Nested task flag]** 这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。
- **RF(bit 16) [Resume flag]** 控制处理器对调试异常的响应。
- **VM(bit 17) [Virtual-8086 mode flag]** 置1以允许虚拟8086模式，清除则返回保护模式。
- **AC(bit 18) [Alignment check flag]** 该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。
- **VIF(bit 19) [Virtual interrupt flag]** 该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)
- **VIP(bit 20) [Virtual interrupt pending flag]** 该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。与VIF标志结合使用。
- **ID(bit 21) [Identification flag]** 程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。


EFLAGS寄存器中的有些标志通过使用特殊的通用指令可以直接被修改，但并没有指令能够检查或者修改整个寄存器。通过使用LAHF/SAHF/PUSHF/POPF/POPFD等指令，可以将**EFLAGS寄存器的标志位成组移到程序栈或EAX寄存器，或者从这些设施中将操作后的结果保存到EFLAGS寄存器中**。在EFLAGS寄存器的内容被传送到栈或是EAX寄存器后，可以通过位操作指令(BT,BTS, BTR, BTC)检查或修改这些标志位。当调用中断或异常处理程序时，处理器将在**程序栈**上自动保存EFLAGS的状态值。若在中断或异常处理时发生任务切换，那么EFLAGS寄存器的状态将被保存在**TSS**中，注意是将要被挂起的本次任务的状态。

---
## 三、段地址寄存器

段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址，x86的段寄存器有6个 **CS/DS/ES/SS/FS/GS**，均为**16位**。

### 1、代码段CS

CS段寄存器包含代码段的段选择符，代码段保存正在执行的指令。处理器从代码段读取指令时，使用有CS寄存器中的段选择符与EIP寄存器联合构成的逻辑地址(CS:IP)。EIP保存要执行的下一条指令在代码段中的偏移量。*CS寄存器不能有应用程序**显式地的加载**，相反，可以通过某些指令或处理器内部操作隐式地加载。*这些指令/内部操作，例如过程调用，中断处理，或者任务切换，用于改变程序的执行流，从而导致更新CS寄存器。

### 2、数据段DS/ES/FS/GS

这四个寄存器指向四个数据段。多个数据段的存在允许高效地且安全地访问不同的数据结构类型。例如，可以创建如下的四个数据段：第一个数据段保存当前程序模块的数据结构，第二个数据段保存更高级别程序模块导出的数据，第三个数据段保存动态创建的数据结构，最后一个数据段保存另一个程序共享出来的数据。要想访问更多的数据段，应用程序必须按需将数据段对应的段选择符加载到DS/ES/FS/GS寄存器中的其中一个当中。

### 3、栈段SS

SS寄存器包含栈段的段选择符，这里栈段用于**存储程序/任务/当前正在执行的处理器程序的栈帧**。所有的栈操作都使用SS栈段寄存器来定位栈段。与CS代码段寄存器不同，**SS寄存器可以显式地加载**，这样就允许应用程序*建立多个栈段，并在这些段间切换*。

---
## 四、控制寄存器

86提供了控制寄存器，来决定CPU的操作模式和当前执行的任务的属性。有4个控制寄存器：**CR0、CR1、CR2、CR3，均为32位**，用于控制和确定处理器的操作模式以及当前执行任务的特性，保存全局性和任务无关的机器状态。这几个寄存器是与**分页机制**密切相关的，因此，在**进程管理及虚拟内存管理**中会涉及到这几个寄存器。对控制寄存器的读写是通过mov指令来实现。


### 1、CR0寄存器

CR0中包含6个预定义标志，分为**协处理器控制位**和**保护控制位**两类：


#### CR0中保护控制位：

- **PE：CR0(0)**  是启用保护（Protection Enable）标志。当设置该位时即**开启了保护模式**；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。
- **PG：CR0(31)** 是分页（Paging）标志。当设置该位时即**开启了分页机制**；当复位时则禁止分页机制，此时<font color=#ff0000>所有线性地址等同于物理地址</font>。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。

通过使用PE和PG位选择的处理器工作方式。由于只有在保护方式下才可启用分页机制，所以尽管两个位分别为0和1共可以有四种组合，但只有三种组合方式有效。PE=0且PG=1是无效组合，因此，用PG为1且PE为0的值装入CR0寄存器将引起通用保护异常。需要注意的是，**<font color=#ff0000>PG位的改变将使系统启用或禁用分页机制，因而只有当所执行的程序的代码和至少有一部分数据在线性地址空间和物理地址空间具有相同的地址的情况下，才能改变PG位。</font>**


#### CR0中协处理器控制位：

CR0的4个位：扩展类型位ET、任务切换位TS、仿真位EM和数学存在位MP用于控制80x86浮点（数学）协处理器的操作。CR0的ET位（标志）用于选择与协处理器进行通信所使用的协议，即指明系统中使用的是80387还是80287协处理器。TS、MP和EM位用于确定浮点指令或WAIT指令是否应该产生一个设备不存在（Device Not Available，DNA）异常。这个异常可用来仅为使用浮点运算的任务保存和恢复浮点寄存器。对于没有使用浮点运算的任务，这样做可以加快它们之间的切换操作。

### 2、CR1寄存器

CR1是未定义的控制寄存器，供今后开发的处理器使用，在80386中不能使用CR1，否则会引起无效指令操作异常。

### 3、CR2寄存器

CR2是页故障线性地址寄存器，保存最后一次出现页故障的**全32位线性地址**。在报告页异常时，处理器会把引起异常的线性地址存放在CR2中。因此操作系统中的页异常处理程序可以通过检查CR2的内容来确定线性地址空间中哪一个页面引发了异常

### 4、CR3寄存器

CR3含有**页目录表物理内存基地址**，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）。CR3用于**保存<font color=#ff0000>页目录表的起始物理地址</font>**。由于目录是页对齐的，所以<font color=#ff0000>仅高20位有效，低12 位保留未用。向CR3中装入一个新值时，低12位必须为0；但从CR3中取值时，低12位被忽略。</font>每当用MOV指令重置CR3的值时，会导致分页机制高速缓冲区的内容无效，用此方法，可以在启用分页机制之前，即把PG位置1之前，预先刷新分页机制的高速缓存。CR3寄存器即使在CR0寄存器的PG位或PE位为0时也可装入，如在实模式下也可设置CR3，以便进行分页机制的初始化。**在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，那么处理器不刷新分页高速缓存，以便当任务共享也表时有较快的执行速度。**


---
## 五、系统地址寄存器

系统地址寄存器有全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等，都是保护方式下非常重要的特殊段，它们包含有为段机制所用的重要表格。

### 1、全局描述符表寄存器GDTR

GDTR长**48位**，其中**高32位为基地址，低16位为界限**。由于GDT 不能有GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段提供一个伪描述符。GDTR给定了GDT。GDTR中的段界限以字节为单位。由于段选择子中只有13位作为描述符索引，而每个描述符长8个字节，所以用16位的界限足够。通常，对于含有N个描述符的描述符表的段界限设为**8*N-1**。

### 2、局部描述符表寄存器LDTR

局部描述符表寄存器LDTR规定当前任务使用的局部描述符表LDT。LDTR类似于段寄存器，由**程序员可见的16位的寄存器**和**程序员不可见的高速缓冲寄存器**组成。实际上，每个任务的局部描述符表LDT作为系统的一个特殊段，由一个描述符描述。而用于描述符LDT的描述符存放在GDT中。在初始化或任务切换过程中，把描述符对应任务LDT的描述符的选择子装入LDTR，处理器根据装入LDTR可见部分的选择子，从GDT中取出对应的描述符，并把LDT的基地址、界限和属性等信息保存到LDTR的不可见的高速缓冲寄存器中。随后对LDT的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。LDTR寄存器包含当前任务的LDT的选择子。所以，装入到LDTR的选择子必须确定一个位于GDT中的类型为LDT的系统段描述符，也即选择子中的TI位必须是0，而且描述符中的类型字段所表示的类型必须为LDT。可以用一个空选择子装入LDTR，这表示当前任务没有LDT。在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。如果再把一个TI位为1的选择子装入到段寄存器，将引起异常。

### 3、中断描述符表寄存器IDTR

中断描述符表寄存器IDTR指向中断描述符表IDT。IDTR长**48位**，其中**32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限**。由于80386只支持256个中断异常，所以IDT表最大长度是2K，以字节位单位的段界限为7FFH。IDTR 指示IDT的方式与GDTR指示GDT的方式相同。

### 3、任务状态段寄存器TR

任务状态段寄存器TR包含指示描述**当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段**。任务状态段的格式在后面的文章中介绍。TR也有程序员可见和不可见两部分。当把任务状态段的选择子装入到TR可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。在此之后，对当前任务状态段的访问可快速方便地进行。装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。


---
## 六、调试地址寄存器

调试寄存器主要作用是调试应用代码、系统代码、开发多任务操作系统.来监视代码的运行和处理器的性能。

**DR0-DR3**:保留32位断点的线性地址。
**DR4-DR5**：保留、未定义。

**DR6**：
- B0—B3:断点状态的监测；
- BD:调试寄存器访问监测、置位,表明在指令流中,下一条指令将访问其中的一个调试寄存器；
- BS:单步执行标志位；
- BT:任务转换标志位。

**DR7**:
- L0—L3:局部断点使能标志位；
- G0--G3: 全局断点使能标志位；
- LE AND GE:置位,表明处理器可以监测导致数据断点的指令，推荐置位为1；
- GD:通用监测使能标志位，表明是否开启调试寄存器保护；
- LEN0 through LEN3 : 用来表明相应断点地址寄存器内存位置的大小；
- R/W0 through R/W3: 相应断点的状态。

---
## 七、其他寄存器

**EIP**：主要用于存放当前代码段即将被执行的下一条指令的偏移，但其本质上并不能直接被指令直接访问。这个寄存器指令由控制转移指令、中断及异常所控制。读操作通过执行call指令并取得栈中所存放的地址来实现，而写操作则通过修改程序栈中的返回指令指针并执行RET/IRET指令来完成，因此尽管这个寄存器相当重要，但其实并不是操作系统在实现过程中所需关注的焦点。

**TSC**：（时间戳寄存器）每个时钟周期时其值加1，重启时清零。通过*RDTSC指令*读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。

**浮点寄存器**：由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。


---
